"""Create and control a 3D object.

This class can be used to create a 3D object, based on vertices and faces. It
can be used to create the main brain or areas (like brodmann / gyrus). This
class is also responsible of turning camera rotations into light ajustement.

This class inherit from vispy.visuals so it can be turned into a vispy node,
which make it easier to add vispy transformations.
"""

import numpy as np
from warnings import warn

from vispy import gloo
from vispy.visuals import Visual
import vispy.visuals.transforms as vist
from vispy.scene.visuals import create_visual_node

from ..utils import (array2colormap, color2vb, vpnormalize, convert_meshdata,
                     vispy_array)

__all__ = ['BrainMesh']


# Vertex shader : executed code for individual vertices. The transformation
# applied to each one of them is the camera rotation.
VERT_SHADER = """
#version 120
varying vec3 v_position;
varying vec4 v_color;
varying vec3 v_normal;

void main() {
    v_position = $a_position;
    v_normal = $a_normal;
    v_color = $a_color * $u_color;
    gl_Position = $transform(vec4($a_position, 1));
}
"""


# Fragment shader : executed code to each Fragment generated by the
# Rasterization and turn it into a set of colors and a single depth value.
# The code bellow generate three types of light :
# * Ambient : uniform light across fragments
# * Diffuse : ajust light according to normal vector
# * Specular : add some high-density light for a "pop / shiny" effect.
FRAG_SHADER = """
#version 120
varying vec3 v_position;
varying vec4 v_color;
varying vec3 v_normal;

void main() {

    // ----------------- Ambient light -----------------
    vec3 ambientLight = $u_coefAmbient * v_color.rgb * $u_light_intensity;


    // ----------------- Diffuse light -----------------
    // Calculate the vector from this pixels surface to the light source
    vec3 surfaceToLight = $u_light_position - v_position;

    // Calculate the cosine of the angle of incidence
    float brightness = dot(v_normal, surfaceToLight) / (length(surfaceToLight) * length(v_normal));
    // brightness = clamp(brightness, 0, 1);
    brightness = max(min(brightness,1.0),0.0);

    // Get diffuse light :
    vec3 diffuseLight =  v_color.rgb * brightness * $u_light_intensity;


    // ----------------- Specular light -----------------
    vec3 surfaceToCamera = vec3(0.0, 0.0, 1.0) - v_position;
    vec3 K = normalize(normalize(surfaceToLight) + normalize(surfaceToCamera));
    float specular = clamp(pow(abs(dot(v_normal, K)), 40.), 0.0, 1.0);
    vec3 specularLight = $u_coefSpecular * specular * vec3(1., 1., 1.) * $u_light_intensity;


    // ----------------- Attenuation -----------------
    // float att = 0.0001;
    // float distanceToLight = length($u_light_position - v_position);
    // float attenuation = 1.0 / (1.0 + att * pow(distanceToLight, 2));


    // ----------------- Linear color -----------------
    // Without attenuation :
    vec3 linearColor = ambientLight + specularLight + diffuseLight;

    // With attenuation :
    // vec3 linearColor = ambientLight + attenuation*(specularLight + diffuseLight);

    // ----------------- Gamma correction -----------------
    // vec3 gamma = vec3(1.0/1.2);


    // ----------------- Final color -----------------
    // Without gamma correction :
    gl_FragColor = vec4(linearColor, v_color.a);

    // With gamma correction :
    // gl_FragColor = vec4(pow(linearColor, gamma), v_color.a);
}
"""


class BrainVisual(Visual):
    """Create and control a mesh of a 3D object.

    This class can be used to create a vispy compatible object. This object
    can then be wrap with a vispy.Node (which is convenient for adding
    transformations to it).
    The BrainVisual is the lowest level class to create a 3D MNI brain (or any
    type of 3D objects). Light is automatically ajust acording to camera
    rotations.

    Parameters
    ----------
    vertices : array_like | None
        Vertices to set of shape (N, 3) or (M, 3)
    faces : array_like | None
        Faces to set of shape (M, 3)
    normals : array_like | None
        The normals to set (same shape as vertices)
    camera : vispy | None
        Add a camera to the mesh. This object must be a vispy edfault
        camera.
    meshdata : vispy.meshdata | None
        Custom vispy mesh data
    color : tuple/string/hex | None
        Alternatively, you can specify a uniform color.
    l_position : tuple | (1., 1., 1.)
        Tuple of three floats defining (x, y, z) light position.
    l_color : tuple | (1., 1., 1., 1.)
        Tuple of four floats defining (R, G, B, A) light color.
    l_intensity : tuple | (1., 1., 1.)
        Tuple of three floats defining (x, y, z) light intensity.
    l_ambient : float | 0.05
        Coefficient for the ambient light
    l_specular : float | 0.5
        Coefficient for the specular light
    scale_factor : float | 10.
        Rescale the mesh between (-scale_factor, scale_factor).
    hemisphere : string | 'both'
        Choose if an hemisphere has to be selected ('both', 'left', 'right')
    recenter : bool | True
        Recenter the mesh arround 0. This is convenient using OpenGL and
        for rotation control.
    lr_index : int | None
        Integer which specify the index where to split left and right
        hemisphere.
    vertfcn : VisPy.transform | None
        Transformation to apply to vertices using get_vertices.
    """

    def __len__(self):
        """Return the length of faces."""
        return len(self._vertFaces)

    def __iter__(self):
        """Iteration function."""
        pass

    def __getitem__(self):
        """Get a specific item."""
        pass

    def __init__(self, vertices=None, faces=None, normals=None,
                 hemisphere='both', lr_index=None, l_position=(1., 1., 1.),
                 l_color=(1., 1., 1., 1.), l_intensity=(1., 1., 1.),
                 l_ambient=.05, l_specular=.5, scale_factor=10., recenter=True,
                 vertfcn=None, camera=None, meshdata=None):
        """Init."""
        self._color_changed = False
        self._hemisphere = hemisphere
        self._recenter = recenter
        self._scaleFactor = scale_factor
        self._lr_index = None
        self._camera = None
        self._camera_transform = vist.NullTransform()

        # Initialize the vispy.Visual class with the vertex / fragment buffer :
        Visual.__init__(self, vcode=VERT_SHADER, fcode=FRAG_SHADER)

        # _________________ TRANSFORMATIONS _________________
        self._btransform = vist.NullTransform()
        self._vertfcn = vist.NullTransform() if vertfcn is None else vertfcn

        # _________________ BUFFERS _________________
        # Vertices / faces / normals / color :
        self._vertBuff = gloo.VertexBuffer(np.zeros((0, 3), dtype=np.float32))
        self._faceBuff = gloo.IndexBuffer()
        self._coloBuff = gloo.VertexBuffer(np.zeros((0, 4), dtype=np.float32))
        self._normaBuff = gloo.VertexBuffer(np.zeros((0, 3), dtype=np.float32))

        # _________________ PROGRAMS _________________
        self.shared_program.vert['a_position'] = self._vertBuff
        self.shared_program.vert['a_color'] = self._coloBuff
        self.shared_program.vert['a_normal'] = self._normaBuff

        # _________________ DATA / LIGHT / CAMERA _________________
        self.set_data(vertices, faces, normals, hemisphere)
        self.set_light(l_position, l_color, l_intensity, l_ambient, l_specular)
        self.set_camera(camera)

        # _________________ GL STATE _________________
        self.set_gl_state('translucent', depth_test=True, cull_face=False,
                          blend=True, blend_func=('src_alpha',
                                                  'one_minus_src_alpha'))
        self._draw_mode = 'triangles'
        self.freeze()

    # =======================================================================
    # =======================================================================
    # Set data / light / camera / clean
    # =======================================================================
    # =======================================================================
    def set_data(self, vertices=None, faces=None, normals=None,
                 hemisphere='both', lr_index=None, meshdata=None,
                 invert_normals=False):
        """Set data to the mesh.

        Parameters
        ----------
        vertices : ndarray | None
            Vertices to set of shape (N, 3) or (M, 3)
        faces : ndarray | None
            Faces to set of shape (M, 3)
        normals : ndarray | None
            The normals to set (same shape as vertices)
        meshdata : vispy.meshdata | None
            Custom vispy mesh data
        hemisphere : string | 'both'
            Choose if an hemisphere has to be selected ('both', 'left',
            'right')
        invert_normals : bool | False
            Sometimes it appear that the brain color is full
            black. In that case, turn this parameter to True
            in order to invert normals.
        """
        # ____________________ VERTICES / FACES / NORMALS ____________________
        vertices, faces, normals = convert_meshdata(vertices, faces, normals,
                                                    meshdata, invert_normals)

        # ____________________ TRANSFORMATIONS ____________________
        if self._recenter:
            # Recenter the brain around (0, 0, 0) and rescale it:
            self._btransform = vpnormalize(vertices, 2 * self._scaleFactor)

            # Keep maximum/minimum per coordinates :
            self._vertsize = [(vertices[:, 0, 0].min(),
                               vertices[:, 0, 0].max()),
                              (vertices[:, 1, 0].min(),
                               vertices[:, 1, 0].max()),
                              (vertices[:, 2].min(),
                               vertices[:, 2].max())]
            self._vertsize = np.array(self._vertsize)

            # Find ratio for the camera :
            self._camratio = self._vertsize.max(1) * 2
            self._camratio *= self._scaleFactor / self._camratio.max()

        # ____________________ HEMISPHERE ____________________
        # Load only left/ritgh hemisphere :
        if hemisphere in ['left', 'right']:
            # Find index to keep only left or right hemisphere :
            if hemisphere == 'left':
                if lr_index is None:
                    inf = np.where(
                        vertices[..., 0, 0] <= vertices[:, :, 0].mean())[0]
                else:
                    inf = lr_index
            if hemisphere == 'right':
                if lr_index is None:
                    inf = np.where(
                        vertices[..., 0, 0] >= vertices[:, :, 0].mean())[0]
                else:
                    inf = ~lr_index
            vertices = vertices[inf, ...]
            normals = normals[inf, ...]
            faces = faces[inf, ...]

        # ____________________ ASSIGN ____________________
        self._vertFaces = vertices
        self._tri = faces
        self._normFaces = normals
        self._colFaces = np.ones((faces.shape[0], 3, 4), dtype=np.float32)

        # ____________________ BUFFERS ____________________
        self._vertBuff.set_data(self._vertFaces, convert=True)
        self._faceBuff.set_data(self._tri, convert=True)
        self._normaBuff.set_data(self._normFaces, convert=True)
        self._coloBuff.set_data(self._colFaces, convert=True)
        self.update()

    def set_color(self, data=None, color='white', alpha=1.0, **kwargs):
        """Set specific colors on the brain.

        Parameters
        ----------
        data : array_like | None
            Data to use for the color. If data is None, the color will
            be uniform using the color parameter. If data is a vector,
            the color is going to be deduced from this vector. If data
            is a (N, 4) it will be interpreted as a color.
        color : tuple/string/hex | 'white'
            The default uniform color
        alpha : float | 1.0
            Opacity to use if data is a vector
        kwargs : dict | { }
            Further arguments are passed to the colormap function.
        """
        # Color to RGBA :
        color = color2vb(color, len(self))

        # Color management :
        if data is None:  # uniform color
            col = np.tile(color, (len(self), 1))
        elif data.ndim == 1:  # data vector
            col = array2colormap(data.copy(), **kwargs)
        elif (data.ndim > 1) and (data.shape[1] == 4):
            col = vispy_array(data)
        else:
            col = data

        # Adapt for faces :
        if col.ndim != 3:
            col = np.transpose(np.tile(col[..., np.newaxis], (1, 1, 3)),
                               (0, 2, 1))

        self._colFaces = np.ascontiguousarray(col, dtype=np.float32)
        self._coloBuff.set_data(self._colFaces)
        self.update()

    def set_alpha(self, alpha, index=None):
        """Set transparency to the brain.

        Prameters
        ---------
        alpha : float
            Transparency level.
        index : array_like | None
            Index for sending alpha. Used by slices.
        """
        if index is None:
            self._colFaces[..., -1] = np.float32(alpha)
        else:
            self._colFaces[index, -1] = np.float32(alpha)
        self._coloBuff.set_data(self._colFaces)
        self.update()

    def set_light(self, l_position=None, l_color=None, l_intensity=None,
                  l_ambient=None, l_specular=None):
        """Set light properties.

        Parameters
        ----------
        l_position: tuple | (1., 1., 1.)
            Position of the light
        l_color: tuple | (1., 1., 1., 1.)
            Color of the light (RGBA)
        l_intensity: tuple | (1., 1., 1.)
            Intensity of the light
        l_ambient: float | 0.11
            Coefficient for the ambient light
        l_specular: float | 0.5
            Coefficient for the specular light
        """
        # Light position :
        if l_position is not None:
            self._l_position = l_position
            self.shared_program.frag['u_light_position'] = l_position
        # Light color :
        if l_color is not None:
            self._l_color = l_color
            self.shared_program.vert['u_color'] = l_color
        # Light ambient coefficient :
        if l_ambient is not None:
            self._l_ambient = l_ambient
            self.shared_program.frag['u_coefAmbient'] = l_ambient
        # Light specular coefficient :
        if l_specular is not None:
            self._l_specular = l_specular
            self.shared_program.frag['u_coefSpecular'] = l_specular
        # Light intensity :
        if l_intensity is not None:
            self._l_intensity = l_intensity
            self.shared_program.frag['u_light_intensity'] = l_intensity
        self.update()

    def set_camera(self, camera=None):
        """Set a camera to the mesh.

        This is essential to add to the mesh the link between the camera
        rotations (transformation) to the vertex shader.

        Parameters
        ----------
        camera : vispy.camera | None
            Set a camera to the Mesh for light adaptation
        """
        if camera is not None:
            self._camera = camera
            self._camera_transform = self._camera.transform
            self.update()

    def clean(self):
        """Clean the mesh.

        This method delete the object from GPU memory.
        """
        # Delete vertices / faces / colors / normals :
        self._vertBuff.delete()
        self._faceBuff.delete()
        self._coloBuff.delete()
        self._normaBuff.delete()

    # =======================================================================
    # =======================================================================
    # Drawing functions
    # =======================================================================
    # =======================================================================

    def draw(self, *args, **kwds):
        """Call when drawing only."""
        Visual.draw(self, *args, **kwds)

    def _prepare_draw(self, view=None):
        """Call everytime there is an interaction with the mesh."""
        view_frag = view.view_program.frag
        view_frag['u_light_position'] = self._camera_transform.map(
            self._l_position)[0:-1]

    @staticmethod
    def _prepare_transforms(view):
        """First rendering call."""
        tr = view.transforms
        transform = tr.get_transform()

        view_vert = view.view_program.vert
        view_vert['transform'] = transform

    def projection(self, projection):
        """Switch between internal/external rendering.

        Parameters
        ----------
        projection : string
            Use either 'internal' or 'external'
        """
        l_color = list(self._l_color)
        if projection == 'internal':
            self.set_gl_state('translucent', depth_test=False, cull_face=False)
            l_color[3] = 0.1
        else:
            self.set_gl_state('translucent', depth_test=True, cull_face=False)
            l_color[3] = 1.
        self.set_light(l_color=l_color)
        self.update_gl_state()

    # =======================================================================
    # =======================================================================
    # Properties
    # =======================================================================
    # =======================================================================

    @property
    def get_vertices(self):
        """Mesh data."""
        return self._vertfcn.map(self._vertFaces)[..., 0:-1]

    @property
    def get_color(self):
        """Vertex color."""
        return self._colFaces

    @property
    def get_light(self):
        """List of all light properties."""
        return list(self._l_position) + list(self._l_intensity) + list(
            self._l_color) + list(tuple([self._l_ambient, self._l_specular]))


BrainMesh = create_visual_node(BrainVisual)
