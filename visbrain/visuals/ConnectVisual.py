"""Create and control a connectivity object.

This class can be used to create and to control a connectivity object, by
setting node positions, connexion strength, the way of coloring connexions,
dynamic control of transparency...

This class inherit from vispy.visuals so it can be turned into a vispy node,
which make it easier to add vispy transformations.
"""

import numpy as np
from collections import Counter

from vispy import gloo, visuals
from vispy.scene.visuals import create_visual_node

from ..utils import array2colormap, normalize, color2vb


__all__ = ['ConnectMesh']

# Vertex shader : executed code for individual vertices. The transformation
# applied to each one of them is the camera rotation.
vertex_shader = """
varying vec4 v_color;
void main()
{
    v_color = $a_color;
    gl_Position = $transform(vec4($a_position, 1));
}
"""

# Fragment shader : executed code to each Fragment generated by the
# Rasterization and turn it into a set of colors and a single depth value.
# Each single fragment is unicolor.
fragment_shader = """
varying vec4 v_color;
void main() {
    gl_FragColor = v_color;
}
"""


class ConnectVisual(visuals.Visual):
    """Create and control a connectivity object.

    This class can be used to create a connectivity object with several
    embeded functions for control color, connexion types...

    Args:
        pos: ndarray
            Position of each node. Must be a (N, 3) array.

        connect: ndarray
            Connection strength between each node. Must be a (N, N) array. The
            diagonal will be systematically ignored. Alternatively, the connect
            array can be turned into a masked array so that some connections
            can be ignored (or use the select parameter to do the same trick.)

    Kargs:
        select: ndarray, optional, (def: None)
            Select the connexions to consider or to igore. The select array
            must be a (N, N) array of boolean values. Alternatively, use a
            masked connect array in place of this parameter.

        colorby: string, optional, (def: 'strength')
            Define the way of coloring connexions. Use 'strength' so that the
            color materialize the strength of connexion between two nodes. Use
            'count' so that the color materialize the number of connections per
            node.

        colval: dict, optional, (def: None)
            Define colors for a specifics values. For example, c_colval=
            {1.5: 'red', 2.1: 'blue'} every connexions equal to 1.5 are going
            to be red and blue for 2.1. Use np.nan: 'gray' in order to define
            the color of all connexions that are not in the dictionary
            otherwise they are going to be ignored.

        dynamic: tuple, optional, (def: None)
            Dynamic transparency. The dynamic parameter must be a tuple of two
            floats, each one between 0 (include) and 1 (include) and
            dynamic[0] < dynamic[1]. Connexion line transparency will be
            normalized between dynamic[0] and dynamic[1] and will be
            proportional to the connexion strength so that weakest
            connexion strength will be more transparent. This parameter is
            usefull to add some depth to the plot.

        cmap: string, optional, (def: 'viridis')
            The matplotlib colormap to use.

        clim: tuple/list, optional, (def: None)
            Limit of the colormap. The clim parameter must be a tuple / list
            of two float number each one describing respectively the (min, max)
            of the colormap. Every values under clim[0] or over clim[1] will
            peaked.

        vmin: float, optional, (def: None)
            Threshold from which every color will have the color defined using
            the under parameter bellow.

        under: tuple/string, optional, (def: None)
            Matplotlib color for values under vmin.

        vmax: float, optional, (def: None)
            Threshold from which every color will have the color defined using
            the over parameter bellow.

        over: tuple/string, optional, (def: 'darkred')
            Matplotlib color for values over vmax.
    """

    def __init__(self, pos, connect, select=None, colorby='strength',
                 dynamic=None, colval=None, cmap='viridis', clim=None,
                 vmin=None, under=None, vmax=None, over=None):
        """Init."""
        # Initialize the vispy.Visual class with the vertex / fragment buffer :
        visuals.Visual.__init__(self, vertex_shader, fragment_shader)

        # Save variables :
        self.pos = pos
        self.connect = connect
        self.select = select
        self.colorby = colorby
        self.dynamic = dynamic
        self.colval = colval
        self._cmap = cmap
        self._vmin, self._vmax = vmin, vmax
        self._under, self._over = under, over
        self._clim = clim

        # Set data connexions :
        self.set_data(self.connect, self.select)

        # Bind data with lines :
        self._draw_mode = 'lines'
        # self.set_gl_state('translucent', depth_test=False, cull_face=False)

    def _prepare_transforms(self, view):
        """This is call for the first rendering."""
        tr = view.transforms
        view_vert = view.view_program.vert
        # view_frag = view.view_program.frag
        view_vert['transform'] = tr.get_transform()

    # ========================================================================
    # ========================================================================
    # CHECK INPUTS (position / data / color)
    # ========================================================================
    # ========================================================================
    def _check_position(self, pos):
        """Check if position is a float32 type.

        Args:
            pos: ndarray
                Position of each node. Must be a (N, 3) array.
        """
        if pos.shape[1] != 3:
            raise ValueError('Position must be an Nx3 matrix')
        self.pos = pos.astype(np.float32)

    def _check_data(self, connect, select):
        """Check connect and select matrices.

        Args:
            connect: ndarray
                Connection strength between each node. Must be a (N, N) array.
                The diagonal will be systematically ignored. Alternatively, the
                connect array can be turned into a masked array so that some
                connections can be ignored (or use the select parameter to do
                the same trick.)

            select: ndarray, optional, (def: None)
                Select the connexions to consider or to igore. The select array
                must be a (N, N) array of boolean values. Alternatively, use a
                masked connect array in place of this parameter.
        """
        N = self.pos.shape[0]
        # Chech array :
        if (connect.shape != (N, N)) or not isinstance(connect, np.ndarray):
            raise ValueError("c_connect must be an array of "
                             "shape " + str((N, N)))
        if select is None:
            select = np.ones_like(connect)
        if (select.shape != (N, N) or not isinstance(select, np.ndarray)):
            raise ValueError("c_select must be an array of "
                             "shape " + str((N, N)))
        # Mask c_connect :
        try:
            connect.mask
        except:
            connect = np.ma.masked_array(connect, mask=True)
        connect.mask[select.nonzero()] = False
        # Use specific color values :
        if (self.colval is not None) and isinstance(self.colval, dict):
            mask = np.ones_like(connect.mask)
            for k, v in zip(self.colval.keys(), self.colval.values()):
                mask[connect.data == k] = False
                self.colval[k] = color2vb(v)
            connect.mask = mask
        self.connect = connect

    def _check_color(self, colorby, cmap, dynamic):
        """Check color parameter.

        Args:
            colorby: string, optional, (def: 'strength')
                Define the way of coloring connexions. Use 'strength' so that
                the color materialize the strength of connexion between two
                nodes. Use 'count' so that the color materialize the number of
                connections per node.

            cmap: string, optional, (def: 'viridis')
                The matplotlib colormap to use.

            dynamic: tuple, optional, (def: None)
                Dynamic transparency. The dynamic parameter must be a tuple of
                two floats, each one between 0 (include) and 1 (include) and
                dynamic[0] < dynamic[1]. Connexion line transparency will be
                normalized between dynamic[0] and dynamic[1] and will be
                proportional to the connexion strength so that weakest
                connexion strength will be more transparent. This parameter is
                usefull to add some depth to the plot.
        """
        # Check colorby :
        if self.colorby not in ['count', 'strength']:
            raise ValueError("The colorby parameter must be 'count' or "
                             "'strength'")
        # Test dynamic :
        if (dynamic is not None) and not isinstance(dynamic, tuple):
            raise ValueError("dynamic bust be a tuple")

    # ========================================================================
    # ========================================================================
    # SET FUNCTIONS (position / data / color / opacity)
    # ========================================================================
    # ========================================================================
    def set_position(self, pos):
        """Set the position of each node.

        Args:
            pos: ndarray
                Position of each node. Must be a (N, 3) array.
        """
        # Check pos :
        self._check_position(pos)
        # Set and update pos :
        self.a_position = np.zeros((2*len(self._nnz_x), 3), dtype=np.float32)
        self.a_position[self._Nindices, :] = self.pos[self._indices, :]
        self.update_position()

    def set_data(self, connect, select=None):
        """Set connection strength and select non-masked connexions.

        Args:
            connect: ndarray
                Connection strength between each node. Must be a (N, N) array.
                The diagonal will be systematically ignored. Alternatively, the
                connect array can be turned into a masked array so that some
                connections can be ignored (or use the select parameter to do
                the same trick.)

        Kargs:
            select: ndarray, optional, (def: None)
                Select the connexions to consider or to igore. The select array
                must be a (N, N) array of boolean values. Alternatively, use a
                masked connect array in place of this parameter.
        """
        # Check data :
        self._check_data(connect, select)
        # Find non-zero elements :
        self._non_zero_select()
        # Update data :
        self.set_color(colorby=self.colorby, dynamic=self.dynamic,
                       cmap=self._cmap, vmin=self._vmin, vmax=self._vmax,
                       under=self._under, over=self._over)
        # Update position :
        self.set_position(self.pos)

    def _non_zero_select(self):
        """Find non zeros indices and connection values.

        This method find where there is non-masked connections.
        """
        self._nnz_x, self._nnz_y = np.where(~self.connect.mask)
        self._indices = np.c_[self._nnz_x, self._nnz_y].flatten()
        self._Nindices = np.arange(len(self._indices))

    def set_color(self, colorby='strength', dynamic=False, cmap='viridis',
                  clim=None, vmin=None, under=None, vmax=None, over=None):
        """Set the connexions colors, either by strength or count.

        This method can be used to assign colors to the connexions, either
        coloring by connexions strength or coloring by the number of connexions
        per node.

        Kargs:
            colorby: string, optional, (def: 'strength')
                Define the way of coloring connexions. Use 'strength' so that
                the color materialize the strength of connexion between two
                nodes. Use 'count' so that the color materialize the number of
                connections per node.

            dynamic: tuple, optional, (def: None)
                Dynamic transparency. The dynamic parameter must be a tuple of
                two floats, each one between 0 (include) and 1 (include) and
                dynamic[0] < dynamic[1]. Connexion line transparency will be
                normalized between dynamic[0] and dynamic[1] and will be
                proportional to the connexion strength so that weakest
                connexion strength will be more transparent. This parameter is
                usefull to add some depth to the plot.

            cmap: string, optional, (def: 'viridis')
                The matplotlib colormap to use.

            clim: tuple/list, optional, (def: None)
                Limit of the colormap. The clim parameter must be a tuple /
                list of two float number each one describing respectively the
                (min, max) of the colormap. Every values under clim[0] or over
                clim[1] will peaked.

            vmin: float, optional, (def: None)
                Threshold from which every color will have the color defined
                using the under parameter bellow.

            under: tuple/string, optional, (def: None)
                Matplotlib color for values under vmin.

            vmax: float, optional, (def: None)
                Threshold from which every color will have the color defined
                using the over parameter bellow.

            over: tuple/string, optional, (def: 'darkred')
                Matplotlib color for values over vmax.
        """
        # Check color elements :
        self._check_color(colorby, cmap, dynamic)

        # Colorby strength of connection :
        if colorby == 'strength':
            # Get non-zeros-values :
            nnz_values = self.connect.compressed()
            # Concatenate in alternance all non-zero values :
            self._all_nnz = np.c_[nnz_values, nnz_values].flatten()
            # Get looping indices :
            self._loopIndex = self._Nindices

        # Colorby count on each node :
        elif colorby == 'count':
            # Count the number of occurence for each node :
            node_count = Counter(np.ravel([self._nnz_x, self._nnz_y]))
            self._all_nnz = np.array([node_count[k] for k in self._indices])
            # Get looping indices :
            self._loopIndex = self._Nindices

        # Get (min / max) :
        self._MinMax = (self._all_nnz.min(), self._all_nnz.max())

        # Get associated colormap :
        if (self.colval is not None) and isinstance(self.colval, dict):
            # Build a_color and send to buffer :
            self.a_color = np.zeros((2*len(self._nnz_x), 4), dtype=np.float32)
            for k, v in zip(self.colval.keys(), self.colval.values()):
                self.a_color[self._all_nnz == k, :] = v
        else:
            colormap = array2colormap(self._all_nnz, cmap=cmap, vmin=vmin,
                                      vmax=vmax, under=under, over=over,
                                      clim=clim)

            # Dynamic alpha :
            if (dynamic is not False) and isinstance(dynamic, tuple):
                colormap[:, 3] = normalize(self._all_nnz, tomin=dynamic[0],
                                           tomax=dynamic[1])

            # Build a_color and send to buffer :
            self.a_color = np.zeros((2*len(self._nnz_x), 4), dtype=np.float32)
            self.a_color[self._Nindices, :] = colormap[self._loopIndex, :]
        self.update_color()

    def set_opacity(self, alpha=1.):
        """Set transparency level of each connexion.

        Kargs:
            alpha: float, optional, (def: 1.)
                The transparency level. This parameter must be a float number
                between 0. and 1.
        """
        N = self.a_color.shape[0]
        if isinstance(alpha, (int, float)):
            alpha_vec = np.full((N,), alpha)
        elif isinstance(alpha, np.ndarray) and (len(alpha) != N):
            raise ValueError("The length of alpha must be " + str(N))
        else:
            alpha_vec = alpha.ravel()
        self.a_color[:, 3] = alpha_vec
        self.update_color()

    # ========================================================================
    # ========================================================================
    # UPDATE FUNCTIONS (position / color)
    # ========================================================================
    # ========================================================================
    def update_position(self):
        """Update node positions."""
        self.shared_program.vert['a_position'] = gloo.VertexBuffer(
                                            self.a_position.astype(np.float32))

    def update_color(self):
        """Update connexions colors."""
        self.shared_program.vert['a_color'] = gloo.VertexBuffer(
                                            self.a_color.astype(np.float32))

    # ========================================================================
    # ========================================================================
    # GET FUNCTIONS (position / data / color / opacity)
    # ========================================================================
    # ========================================================================
    @property
    def get_position(self):
        """Get nodes positions."""
        return self.shared_program.vert['a_position']

    @property
    def get_color(self):
        """Get connexions colors."""
        return self.shared_program.vert['a_color']

    @property
    def get_MinMax(self):
        """Get the (min, max) connexions strength."""
        return self._MinMax

ConnectMesh = create_visual_node(ConnectVisual)
